<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Agujero Negro</title>
<style>

    @font-face {
        font-family: NOTT;
        src:url(Caveat-Regular.ttf)
        format("truetype");
    }
       
body {
  margin: 0;
  overflow: hidden;
  background: radial-gradient(circle at center, #0a001a, #000);
}

canvas {
  display: block;
}
</style>
</head>
<body>

<canvas id="space"></canvas>
<canvas id="space"></canvas>


<script>
const canvas = document.getElementById("space");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const centerX = canvas.width / 2;
const centerY = canvas.height / 2;

let words = ["Te amo", "Perfecta", "Destino", "Eterno", "Mia", "Maravillosa", "Juntos","Hermosa","Linda","Provocativa","Sexy","Bellisima"];

let particles = [];

function createWord() {
  const angle = Math.random() * Math.PI * 2;
  const radius = Math.random() * 400 + 200;

  const x = centerX + Math.cos(angle) * radius;
  const y = centerY + Math.sin(angle) * radius;

  particles.push({
    text: words[Math.floor(Math.random() * words.length)],
    x: x,
    y: y,
    speed: 0.5 + Math.random() * 0.5
  });
}

//  Estrella de salida
let starExit = {
  x: centerX + 300, 
  y: centerY - 200,
  radius: 20,
  color: "yellow",
  exploding: false,
  particles: []
};

// Detectar click sobre la estrella
canvas.addEventListener("click", (e) => {
  const dx = e.clientX - starExit.x;
  const dy = e.clientY - starExit.y;
  if (!starExit.exploding && Math.sqrt(dx*dx + dy*dy) < starExit.radius) {
    starExit.exploding = true;
    createExplosion(starExit);
  }
});

// Crear part铆culas de explosi贸n
function createExplosion(star) {
  for (let i = 0; i < 30; i++) {
    star.particles.push({
      x: star.x,
      y: star.y,
      dx: (Math.random() - 0.5) * 8,
      dy: (Math.random() - 0.5) * 8,
      alpha: 1
    });
  }
}

// Dibujar estrella y explosi贸n
function drawStarExit() {
  if (!starExit.exploding) {
    ctx.beginPath();
    ctx.arc(starExit.x, starExit.y, starExit.radius, 0, Math.PI*2);
    ctx.fillStyle = starExit.color;
    ctx.fill();
  } else {
    starExit.particles.forEach((p, i) => {
      ctx.fillStyle = `rgba(255, 255, 0, ${p.alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 5, 0, Math.PI*2);
      ctx.fill();
      p.x += p.dx;
      p.y += p.dy;
      p.alpha -= 0.03;
      if (p.alpha <= 0) starExit.particles.splice(i, 1);
    });

    // Cuando termina la explosi贸n, redirige
    if (starExit.particles.length === 0) {
      window.location.href = "index.html"; // vuelve al principal
    }
  }
}

let nebulosas = [];

for (let i = 0; i < 50; i++) {
  nebulosas.push({
    x: centerX + (Math.random() - 0.5) * 600, // posici贸n alrededor del centro
    y: centerY + (Math.random() - 0.5) * 600,
    radius: Math.random() * 50 + 20,
    color: `rgba(${100 + Math.random()*155}, 0, ${150 + Math.random()*105}, 0.2)`,
    dx: (Math.random() - 0.5) * 0.2, // movimiento lento
    dy: (Math.random() - 0.5) * 0.2
  });
}


function drawBlackHole() {
  // Centro oscuro
  ctx.beginPath();
  ctx.arc(centerX, centerY, 90, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.fill();

  // Horizonte de sucesos (anillo brillante)
  const pulse = 10 * Math.sin(Date.now() * 0.003);

  const gradient = ctx.createRadialGradient(
    centerX,
    centerY,
    90,
    centerX,
    centerY,
    140 + pulse
  );

  gradient.addColorStop(0, "rgba(150, 0, 255, 0.9)");
  gradient.addColorStop(0.4, "rgba(200, 0, 255, 0.6)");
  gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

  ctx.beginPath();
  ctx.arc(centerX, centerY, 140 + pulse, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();
}


function update() 

{
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawStarExit();


  // Dibujar nebulosas
nebulosas.forEach(n => {
  n.x += n.dx;
  n.y += n.dy;

  const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.radius);
  gradient.addColorStop(0, n.color);
  gradient.addColorStop(1, "rgba(0,0,0,0)");

  ctx.beginPath();
  ctx.arc(n.x, n.y, n.radius, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();
});


  // 1锔 Dibujar palabras primero
  particles.forEach((p, index) => {
    const dx = centerX - p.x;
    const dy = centerY - p.y;

    p.x += dx * 0.01 * p.speed;
    p.y += dy * 0.01 * p.speed;

    const distance = Math.sqrt(dx * dx + dy * dy);

    // Si entra en la singularidad (radio 90), desaparece
    if (distance < 90) {
      particles.splice(index, 1);
      return;
    }

    ctx.fillStyle = "white";
    ctx.font = "22px NOTT,cursive";
    ctx.fillText(p.text, p.x, p.y);
  });

  // 2锔 Dibujar horizonte brillante
  const pulse = 10 * Math.sin(Date.now() * 0.003);

  const gradient = ctx.createRadialGradient(
    centerX,
    centerY,
    90,
    centerX,
    centerY,
    140 + pulse
  );

  gradient.addColorStop(0, "rgba(150, 0, 255, 0.9)");
  gradient.addColorStop(0.4, "rgba(200, 0, 255, 0.6)");
  gradient.addColorStop(1, "rgba(0, 0, 0, 0)");

  ctx.beginPath();
  ctx.arc(centerX, centerY, 140 + pulse, 0, Math.PI * 2);
  ctx.fillStyle = gradient;
  ctx.fill();

  // 3锔 Dibujar centro negro al FINAL
  ctx.beginPath();
  ctx.arc(centerX, centerY, 90, 0, Math.PI * 2);
  ctx.fillStyle = "black";
  ctx.fill();

  requestAnimationFrame(update);
}

  drawBlackHole();

  particles.forEach((p, index) => {
    const dx = centerX - p.x;
    const dy = centerY - p.y;

    p.x += dx * 0.01 * p.speed;
    p.y += dy * 0.01 * p.speed;

    ctx.fillStyle = "white";
    ctx.font = "20px NOTT";
    ctx.fillText(p.text, p.x, p.y);

    if (Math.abs(dx) < 10 && Math.abs(dy) < 10) {
      particles.splice(index, 1);
    }
  });

  requestAnimationFrame(update);


setInterval(createWord, 1000);
update();
</script>

</body>
</html>